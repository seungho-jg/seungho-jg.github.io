[{"id":"1728881378762","title":"단어 변환","subtitle":"프로그래머스 DFS/BFS","tags":["알고리즘"],"content":"[https://school.programmers.co.kr/learn/courses/30/lessons/43163?language=python3](https://school.programmers.co.kr/learn/courses/30/lessons/43163?language=python3)\n\n### 문제풀이\n\n| begin | target | words | return |\n| -------- | -------- | -------- | -------- |\n| \"hit\" | \"cog\" | \t[\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] | 4 |\n| \"hit\" | \"cog\" | [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]\t | 0 |\n\n> 먼저 한글자 차이인지 확인하기 위해서 비교하는 함수를 만들었다.\n\n```javascript\n# 문자열 비교함수\ndef comp_str(str_a, str_b):\n    count = 0\n    for a, b in zip(str_a, str_b):\n        if a != b:\n            count += 1\n    return count\n```\n>최단경로를 찾는 문제라 BFS가 더 적합해 보이지만 words 갯수가 최대 50개 이하여서 그냥 DFS로 풀어버렸다.\n\n```javascript\n# global\nmin_v = 100\n\n# dfs 재귀함수\ndef dfs(current, target, visit, words, depth):\n    global min_v\n    if current == target:\n        if depth < min_v:\n            min_v = depth\n    for i, w in enumerate(words):\n        if comp_str(current, w) == 1 and visit[i] == 0:\n            visit[i] = 1\n            dfs(w, target, visit, words, depth+1)\n            visit[i] = 0\n    if min_v == 100:\n        return 0\n    return min_v\n\n\ndef solution(begin, target, words):\n    answer = 0\n    # 만들 수 없다면 0 리턴\n    if target not in words:\n        return 0\n\n    visit = [0] * len(words)\n    return dfs(begin, target, visit, words, 0)\n```\n\n일단 만들 수 없다면 바로 0을 리턴하고 나머지는 dfs 재귀를 통해 완전탐색으로 global 최솟값을 \n갱신하는 방식으로 해결했다. 뭔가 생각없이 풀다보니까 좀 코드가 난해해졌다.\n","date":"2024-10-14"},{"id":"1728822142432","title":"webGL 기초-1","subtitle":"webGL이란, shader란","tags":["webgl","cg"],"content":"![](https://mblogthumb-phinf.pstatic.net/MjAyMzA3MjZfMjcx/MDAxNjkwMzM3MjIzNDI2.sbhOUlKl4x4SXgds-ALuAI5iNy00mdYvG8I9eDTfJAsg.TDABDiOIbY40nwY04mpY7Cwslx2hRjsko_ubska9TgYg.PNG.dwittt/image.png?type=w800)\n\n### webGL이란 사실 래스터화 엔진이다.\n\n**래스터화(rasterize)**란 **백터**형태의 데이터를 **2d 이미지(2차원 배열)**로 변환하여\n픽셀에 **색상을 할당하는 과정**을 말한다.\n\n>우리가 보는 모니터화면은 GPU내부 메모리, **framebuffer**에 있는 2차원 배열의 **픽셀정보**를 \n>가져와 보여주게 되는데 이때 래스터화에 대한 계산이 **GPU를 통해 병렬적으로 처리된다.**\n\n### shader는 GPU의 병렬처리를 위한 함수이다.\n\n래스터화를 위한 함수인 shader에는 **두가지 shader**가 필요한데 우선 정점의 최종위치를 계산할\n**정점(vertex) shader**와 픽셀의 최종 색상을 계산할 **fragment shader**가 있어야 한다.\nGPU에서 실행되는 셰이더는 C/C++처럼 엄격한 타입을 가지는 GLSL로 작성되어져야 하는데 다음과 같이 정의해 사용할 수 있다.\n\n```javascript\n    // Vertex shader\n    const vertexShaderSource = `\n\t\t// 속성은 버퍼에서 데이터를 받습니다.\n      attribute vec2 a_position;\n\t\t\t// 모든 셰이더는 main 함수를 가집니다.\n      void main() {\n\t\t\t// gl_Position은 정점 셰이더가 설정을 담당하는 특수 변수\n        gl_Position = vec4(a_position, 0, 1.0);\n      }\n    `;\n\n    // Fragment shader\n    const fragmentShaderSource = `\n\t\t// 프래그먼트 셰이더는 기본 정밀도를 가지고 있지 않으므로 하나를 선택해야 합니다.\n\t\t// mediump은 좋은 기본값으로 \"중간 정밀도\"를 의미합니다.\n      precision mediump float;\n\n      void main() {\n        // gl_FragColor는 프래그먼트 셰이더가 설정을 담당하는 특수 변수\n\t\t\t\tgl_FragColor = vec4(1, 0, 0.5, 1); // 자주색 반환\n      }\n    `;\n```\n>이렇게 문자열로 정의된 셰이더를 컴파일해서 GPU에 할당하게 된다.\n\n```javascript\n// 셰이더를 생성하고 컴파일하는 함수\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type); // 셰이더 객체 생성\n  gl.shaderSource(shader, source); // 셰이더 소스 코드 할당\n  gl.compileShader(shader); // 셰이더 컴파일\n\n  // 셰이더 컴파일 상태 확인\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (success) {\n    return shader; // 컴파일 성공 시 셰이더 반환\n  }\n\n  console.log(gl.getShaderInfoLog(shader)); // 컴파일 실패 시 에러 출력\n  gl.deleteShader(shader); // 컴파일 실패 시 셰이더 삭제\n}\n```\n>이제 두 개의 셰이더를 만들고 프로그램으로 연결해줘야 한다.\n\n```javascript\n// 버텍스 및 프래그먼트 셰이더 컴파일\nconst vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\nconst fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n// 셰이더 프로그램을 생성하고 연결하는 함수\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  const program = gl.createProgram(); // 프로그램 객체 생성\n  gl.attachShader(program, vertexShader); // 버텍스 셰이더 연결\n  gl.attachShader(program, fragmentShader); // 프래그먼트 셰이더 연결\n  gl.linkProgram(program); // 프로그램 링크\n\n\t// 셰이더 프로그램 생성 및 링크\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (success) {\n    return program; // 링크 성공 시 프로그램 반환\n  }\n\n  console.log(gl.getProgramInfoLog(program)); // 링크 실패 시 에러 출력\n  gl.deleteProgram(program); // 실패 시 프로그램 삭제\n}\n\nconst program = createProgram(gl, vertexShader, fragmentShader);\n```\n>이렇게 만들어진 WebGL 프로그램을 사용하려면 canvas의 getContext('webgl')로 가져와야한다.\n\n```javascript\n// WebGL 초기화\nconst canvas = document.querySelector(\"#glCanvas\");\nconst gl = canvas.getContext(\"webgl\");\n\n// WebGL이 지원되지 않는 경우 에러 처리\nif (!gl) {\n  console.error(\"WebGL을 지원하지 않는 브라우저입니다.\");\n}\n\n// WebGL 프로그램 사용\ngl.useProgram(program);\n```\n>이제 정점을 버퍼에 담아 연결해주면 된다.\n\n```javascript\n// 정점 데이터를 WebGL 버퍼에 전달\nconst positionBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n// 2D 삼각형 좌표 정의\nconst positions = [\n  0, 0,\n  0, 0.5,\n  0.7, 0\n];\n\n// 버퍼에 정점 데이터 로드\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n// 속성 위치 찾기\nconst positionLocation = gl.getAttribLocation(program, \"a_position\");\n\n// 속성을 활성화하고 버퍼 데이터 연결\ngl.enableVertexAttribArray(positionLocation);\ngl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n// 캔버스 초기화\ngl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\ngl.clearColor(0, 0, 0, 1); // 배경색을 검은색으로 설정\ngl.clear(gl.COLOR_BUFFER_BIT); // 캔버스를 초기화\n\n// 삼각형을 그리기\ngl.drawArrays(gl.TRIANGLES, 0, 3);\n```\n\n\n참조링크\n[https://webglfundamentals.org/webgl/lessons/ko/webgl-fundamentals.html](https://webglfundamentals.org/webgl/lessons/ko/webgl-fundamentals.html)","date":"2024-10-13"},{"id":"1728205463026","title":"[JS] 불변성(Immutability)","subtitle":"원시타입과 객체타입, 리액트와 불변성","tags":["javascript","react"],"content":"불변성을 이해하려면 먼저 자바스크립트에 원시타입과 객체타입을 알아야한다.\n\n### 원시타입과 객체타입\n자바스크립트가 제공하는 7가지 데이터 타입은 크게 **원시타입**(primitive type)과 **객체타입**(object type)으로 구분할 수 있다. *(객체타입에는 당연하게도 객체와 배열이 해당된다.)*\n\n![](https://drive.google.com/u/0/drive-viewer/AKGpihb8-KQ-nfvOOSEX4Ulrf0RaWJcg-l_2ZCEJ0uSv9apHrdR1ps15QwhJUHPCTqMSBGLWDK4LX-e0amJetVxfXbj09HTlJ6ciyWw)\n\n>**원시타입: 한번 할당된 원시 값은 읽기 전용(read only)로 변경할 수 없다.**\n>따라서 원시 값을 변경해야한다면 새로운 메모리공간을 할당받아 변경 후 해당주소로 참조를 바꾼다. \n>**객체타입: 주소를 참조하는 형태로 변경 가능한(mutable) 값**\n>객체타입은 할당된 메모리 주소를 참조하는 방식으로 여러 변수가 동일한 객체를 참조할 수 있다.\n\n#### 🎯 정리하자면 불변성은 데이터가 생성된 후에는 변경되지 않는 것을 의미한다.\n\n### 불변성이 중요한 이유\n```javascript\nconst obj = {}\nobj.a = 1\nconsole.log(obj) // { a: 1 }\n```\n이처럼 데이터가 할당된 이후 값이 **언제, 어디서 변경될지 모르기 때문에** 코드의 예측이 어려워지고\n복잡도가 올라가 **디버깅이 어려워지고 버그가 생기기 쉬운 상황**이 발생할 수 있다.\n\n### 리액트와 불변성\n\nReact에서 컴포넌트가 리렌더링될 때마다 새로운 VDOM을 만들고, 이전의 VDOM과 비교하여\n변경사항을 찾는 **재조정(Reconciliation)**이 이루어진다. 이때 상태 변경 감지를 위해 state의\n메모리 주소를 비교하는 **얕은 비교**가 실행된다. 객체 타입의 경우 값을 수정하더라도 메모리의 주소가\n같기때문에 **불변성을 지키기 위하여** `JSON.parse(JSON.stringify(obj))` 나 `structuredClone(obj)`과\n같이 새로운 **객체를 생성하거나** 배열의 경우 `spread, map, slice, reduce...` 와 같이 **새로운 배\n열을 반환 하는 메소드**를 활용하여 불변성을 유지해야 한다.\n\n```javascript\n// 원시타입\nconst [number, setNumber] = useState(0)\nsetState(3)\n\n// 참조타입\nconst [person, setPerson] = useState({ name: '', age: 20 })\nsetPerson({...person, name: 'seungho'})\n```\n\n","date":"2024-10-06"},{"id":"1728020360585","title":"카펫","subtitle":"프로그래머스 완전탐색","tags":["알고리즘"],"content":"[https://school.programmers.co.kr/learn/courses/30/lessons/42842?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/42842?language=javascript)\n\n### 문제풀이\n\n![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b1ebb809-f333-4df2-bc81-02682900dc2d/carpet.png)\n\n>카펫의 brown, yellow 갯수를 만족하는 카펫의 w, h를 구하는 문제이다.\n\n```javascript\nfunction solution(brown, yellow) {\n    let answer = []\n    let size_list = []\n    // 가능한 노란색 패턴의 w, h값 구하기\n    for (let i = 1; i <= yellow; i++){\n        let size = [] // [w, h]\n        if (yellow % i === 0) {\n            let w = yellow / i\n            let h = i\n            if ( w >= h ) {\n                size_list.unshift([w, h])    \n            }  \n        }\n    }\n    // size_list에서 조건을 만족하는 w, h값 구하기\n    for (size of size_list){\n        let [w, h] = size\n        let calc_wh = (w+2) * (h+2)\n        if ( calc_wh - yellow === brown) {\n            answer.splice(0,0,w+2,h+2)\n            break\n        }\n    }\n    return answer;\n}\n```","date":"2024-10-04"},{"id":"1727781093653","title":"소수찾기","subtitle":"프로그래머스 완전탐색","tags":["알고리즘"],"content":"[https://school.programmers.co.kr/learn/courses/30/lessons/42839](https://school.programmers.co.kr/learn/courses/30/lessons/42839)\n### 문제풀이\n> 이 문제는 가능한 모든 숫자를 찾아서 소수인지 판별하는 문제이다.\n\n우선 소수인지 판별하는 `isPrime` 함수를 만들었다.\n`prime_set` 에 저장해서 중복계산을 최소화 하였고\n풀고나서 기억이 났는데 `for i in range(2, n)` 이 부분을 `for i in range(2, int(n**0.5) +1)`\n이렇게 제곱근까지만 검사해도 소수인지 알 수 있다.\n\n```python\nprime_set = set()\n\ndef isPrime(n):\n    if n < 2:\n        return False\n    elif n in prime_set:\n        return True\n    \n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    \n    prime_set.add(n)    \n    return True\n```\n\n다음은 인풋으로 들어온 `numbers` 에 대한 모든 자리수의 순열을 구하면 되는데 파이썬 `itertools.permutations` 을 써도 되지만 재귀를 통한 백트레킹을 통해 모든 경우의 수를 구해봤다.\n\n```python\ndef solution(numbers, combi=[], answer=set()):\n    if combi:\n        num = int(''.join(combi))\n        if isPrime(num):\n            answer.add(num)\n    for i in range(len(numbers)):\n        combi.append(numbers[i])\n        remain_nums = numbers[:i] + numbers[i+1:]\n        solution(remain_nums, combi, answer)\n        combi.pop()\n\n    return len(answer)\n```","date":"2024-10-01"}]