[{"id":"1728205463026","title":"[JS] 불변성(Immutability)","subtitle":"원시타입과 객체타입, 리액트와 불변성","tags":["javascript","react"],"content":"불변성을 이해하려면 먼저 자바스크립트에 원시타입과 객체타입을 알아야한다.\n\n### 원시타입과 객체타입\n자바스크립트가 제공하는 7가지 데이터 타입은 크게 **원시타입**(primitive type)과 **객체타입**(object type)으로 구분할 수 있다. *(객체타입에는 당연하게도 객체와 배열이 해당된다.)*\n\n![](https://drive.google.com/u/0/drive-viewer/AKGpihb8-KQ-nfvOOSEX4Ulrf0RaWJcg-l_2ZCEJ0uSv9apHrdR1ps15QwhJUHPCTqMSBGLWDK4LX-e0amJetVxfXbj09HTlJ6ciyWw)\n\n>**원시타입: 한번 할당된 원시 값은 읽기 전용(read only)로 변경할 수 없다.**\n>따라서 원시 값을 변경해야한다면 새로운 메모리공간을 할당받아 변경 후 해당주소로 참조를 바꾼다. \n>**객체타입: 주소를 참조하는 형태로 변경 가능한(mutable) 값**\n>객체타입은 할당된 메모리 주소를 참조하는 방식으로 여러 변수가 동일한 객체를 참조할 수 있다.\n\n#### 🎯 정리하자면 불변성은 데이터가 생성된 후에는 변경되지 않는 것을 의미한다.\n\n### 불변성이 중요한 이유\n```javascript\nconst obj = {}\nobj.a = 1\nconsole.log(obj) // { a: 1 }\n```\n이처럼 데이터가 할당된 이후 값이 **언제, 어디서 변경될지 모르기 때문에** 코드의 예측이 어려워지고\n복잡도가 올라가 **디버깅이 어려워지고 버그가 생기기 쉬운 상황**이 발생할 수 있다.\n\n### 리액트와 불변성\n\nReact에서 컴포넌트가 리렌더링될 때마다 새로운 VDOM을 만들고, 이전의 VDOM과 비교하여\n변경사항을 찾는 **재조정(Reconciliation)**이 이루어진다. 이때 상태 변경 감지를 위해 state의\n메모리 주소를 비교하는 **얕은 비교**가 실행된다. 객체 타입의 경우 값을 수정하더라도 메모리의 주소가\n같기때문에 **불변성을 지키기 위하여** `JSON.parse(JSON.stringify(obj))` 나 `structuredClone(obj)`과\n같이 새로운 **객체를 생성하거나** 배열의 경우 `spread, map, slice, reduce...` 와 같이 **새로운 배\n열을 반환 하는 메소드**를 활용하여 불변성을 유지해야 한다.\n\n```javascript\n// 원시타입\nconst [number, setNumber] = useState(0)\nsetState(3)\n\n// 참조타입\nconst [person, setPerson] = useState({ name: '', age: 20 })\nsetPerson({...person, name: 'seungho'})\n```\n\n","date":"2024-10-06"},{"id":"1728020360585","title":"카펫","subtitle":"프로그래머스 완전탐색","tags":["알고리즘"],"content":"[https://school.programmers.co.kr/learn/courses/30/lessons/42842?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/42842?language=javascript)\n\n### 문제풀이\n\n![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b1ebb809-f333-4df2-bc81-02682900dc2d/carpet.png)\n\n>카펫의 brown, yellow 갯수를 만족하는 카펫의 w, h를 구하는 문제이다.\n\n```javascript\nfunction solution(brown, yellow) {\n    let answer = []\n    let size_list = []\n    // 가능한 노란색 패턴의 w, h값 구하기\n    for (let i = 1; i <= yellow; i++){\n        let size = [] // [w, h]\n        if (yellow % i === 0) {\n            let w = yellow / i\n            let h = i\n            if ( w >= h ) {\n                size_list.unshift([w, h])    \n            }  \n        }\n    }\n    // size_list에서 조건을 만족하는 w, h값 구하기\n    for (size of size_list){\n        let [w, h] = size\n        let calc_wh = (w+2) * (h+2)\n        if ( calc_wh - yellow === brown) {\n            answer.splice(0,0,w+2,h+2)\n            break\n        }\n    }\n    return answer;\n}\n```","date":"2024-10-04"},{"id":"1727781093653","title":"소수찾기","subtitle":"프로그래머스 완전탐색","tags":["알고리즘"],"content":"[https://school.programmers.co.kr/learn/courses/30/lessons/42839](https://school.programmers.co.kr/learn/courses/30/lessons/42839)\n### 문제풀이\n> 이 문제는 가능한 모든 숫자를 찾아서 소수인지 판별하는 문제이다.\n\n우선 소수인지 판별하는 `isPrime` 함수를 만들었다.\n`prime_set` 에 저장해서 중복계산을 최소화 하였고\n풀고나서 기억이 났는데 `for i in range(2, n)` 이 부분을 `for i in range(2, int(n**0.5) +1)`\n이렇게 제곱근까지만 검사해도 소수인지 알 수 있다.\n\n```python\nprime_set = set()\n\ndef isPrime(n):\n    if n < 2:\n        return False\n    elif n in prime_set:\n        return True\n    \n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    \n    prime_set.add(n)    \n    return True\n```\n\n다음은 인풋으로 들어온 `numbers` 에 대한 모든 자리수의 순열을 구하면 되는데 파이썬 `itertools.permutations` 을 써도 되지만 재귀를 통한 백트레킹을 통해 모든 경우의 수를 구해봤다.\n\n```python\ndef solution(numbers, combi=[], answer=set()):\n    if combi:\n        num = int(''.join(combi))\n        if isPrime(num):\n            answer.add(num)\n    for i in range(len(numbers)):\n        combi.append(numbers[i])\n        remain_nums = numbers[:i] + numbers[i+1:]\n        solution(remain_nums, combi, answer)\n        combi.pop()\n\n    return len(answer)\n```","date":"2024-10-01"}]